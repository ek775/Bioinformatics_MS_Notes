Methods:
************************************************************************************************
The main functions were copied and pasted from excercise 5.1, 5.2. See associated documentation for details on those functions.

Using the sys module, this script is now able to be executed from the command line and all functions can be called from the terminal directly. Additional arguments passed into the terminal at execution time inform the script which function to call and what sequence to pass to the function. After a validation of the function argument, the script should execute the chosen function on the sequence that was passed to it and print the output of that function to the terminal. 

***ATTENTION***: My original approach to 6.1 included scripting to allow a user to load the sequence from a text file or type in a sequence directly depending on what was passed in as the second argument, so my script for 6.1 and 6.2 is identical. The single script is fully functional for the tasks that both functions ask for. 

Discussion:
************************************************************************************************
This function is identical to the preceding scripts in terms of its backend methodology and carries the same benefits and weaknesses as a result. The primary strength of this script in its current iteration is that it can be executed from a terminal and is thus more user-friendly. However, this script is not functional in an ipython terminal because running it without passing the required arguments in the terminal causes an indexing error. I would argue this specific implementation is a net loss, as an end user who is comfortable executing commands in a terminal would likely get far more utility out of importing this script's functionality for integration into a larger workflow, and all other end users would likely have issues using the terminal interface. This also drastically increases the importance of effective documentation since we will no longer be able to troubleshoot the program without editing it, and our end users need to understand what it is doing before they can use it effectively.

In my specific implementation, I made it possible to pass either a text file or a manually typed sequence into the sequence argument position, thus increasing the program's versatility. It will, however, still cause an exception if you do not pass in either a string literal or a raw text file. There is also very little handling implemented for the wide array of information that can be passed in using either format - meaning if you pass my program a file full of extra information, multiple primers, or something else it isn't expecting, then you might cause an exception or it may return some horrendous looking output. Similarly, I would expect that passing in a .csv file with a list of primers and asking it to return the reverse-complement may result in one massive reverse complement string being returned full of x's where all of the commas were.